面试官您好，我是孔艺睿，来自东华理工大学软件学院网络工程的学生，本次应聘的是贵公司的前端实习生。接下来介绍一下我的学习方法，首先在大一的时候加入了学校的计算机协会，然后发现很多学长在学习前端，就对前端起了兴趣，然后就自主的进行前端学习，前期的时候在b站上学习前端知识，有一定基础后就和学长们一起讨论，学习，到大二的时候，由导师带队进行系统性的学习，平时喜欢在稀土掘金上发表技术文章，也对AI比较感兴趣，比较喜欢使用cursor,trae之类的AI IDE 进行代码编辑，从AIGC 到我现在正在学习的端模型,个人觉得前端+AI应该是一个顺应时代的方向

面试官您好，我叫孔艺睿，是东华理工大学软件学院网络工程专业的学生，很荣幸能够参加贵公司前端实习生的面试。
关于我的学习经历，我想从几个阶段来介绍：
大一时我加入了学校的计算机协会，在与学长们的交流中接触到前端开发，被这个领域的创造性和实用性深深吸引，从而开始了我的前端学习之路。
初期我通过B站等平台系统学习前端基础知识，包括HTML、CSS、JavaScript等核心技术。在掌握一定基础后，我积极与学长们进行技术交流和探讨，在实践中不断提升自己的能力。
到了大二，我有幸在导师的指导下进行更加系统性的学习，这让我对前端开发有了更深入和全面的理解。
我平时喜欢在稀土掘金平台上发表技术文章，既能梳理自己的学习成果，也能与更多开发者交流心得。同时，我对AI技术也很感兴趣，经常使用Cursor、Claude等AI IDE辅助开发工具来提高编程效率，也会玩coze Agent,工作流，从AIGC到目前正在学习的端模型技术，我都保持着浓厚的学习热情。
我认为前端开发与AI技术的结合是技术发展的必然趋势，这不仅能提升开发效率，还能为用户带来更智能的交互体验。我希望能在贵公司这个平台上，将我的前端技能与AI技术相结合，为公司创造更大的价值。  单例模式 分词 数组 维度
谢谢！

**项目介绍**（项目栈，项目介绍，项目亮点）
**面试官您好，我想介绍一下我开发的智旅项目。这个项目最大的挑战是如何在移动端实现一个高性能的社交旅行应用。

首先说说JWT认证系统的实现。我遇到的问题是用户登录状态需要在多个页面间保持，而且要处理token过期的情况。我的解决方案是在Zustand store中集成JWT验证逻辑，用户登录后生成的token会存储在httpOnly cookie中，这样既安全又能防止XSS攻击。关键是我实现了一个token管理器，会在token快过期前30分钟自动刷新，用户完全感知不到这个过程。另外我还做了路由保护，未登录用户访问需要认证的页面会自动跳转到登录页。

瀑布流布局是这个项目的核心功能之一。我参考了小红书的设计，但遇到的技术难点是如何让不同高度的图片自然排列，而且要支持无限滚动。我的实现方式是用CSS Grid配合JavaScript动态计算每个item的位置。具体来说，我维护了一个高度数组来记录每列的当前高度，新的item总是插入到最短的那一列。无限滚动实现 ：当用户距离底部100-200px时，通过scroll事件监听触发加载更多数据，同时实现虚拟滚动优化性能，只渲染可视区域内容，支持上千张图片流畅展示。滚动加载采用分页，节流机制，每次加载20-30张图片，确保用户体验流畅。

轮播组件的实现也很有意思。我遇到的问题是如何实现真正的无限循环轮播，避免从最后一张跳回第一张时的视觉跳跃。我的解决方案是在原始数据的前后各复制一份，比如原本有3张图片，我会创建一个包含5张图片的数组：[3,1,2,3,1]。当用户滑动到复制的第一张时，我会无动画地跳转到真正的第一张，这样用户感觉是连续的。另外我还加了自动播放功能，用户触摸时会暂停，离开后继续播放，体验很流畅。

图片懒加载也是一个重点。我用Intersection Observer API来监听图片是否进入视口，只有当图片即将显示时才开始加载。这里有个细节是我设置了一个预加载距离，当图片距离视口还有200px时就开始加载，这样用户滚动时看到的都是已经加载好的图片。

AI功能集成方面，我接入了Coze的工作流API。这里的技术挑战是如何处理流式响应，因为AI回复是逐字输出的。我用Server-Sent Events来接收数据流，前端用useEffect监听消息事件，每收到一段文字就更新到界面上，还加了打字机效果让体验更自然。另外我还集成了豆包的图像生成API，用户可以根据旅行偏好生成个性化头像。

移动端适配我用了lib-flexible配合postcss-pxtorem的方案。px可以自动转换成rem单位，在不同屏幕上都能完美适配。特别是在处理1px边框问题时，我用了transform scale的方式来实现真正的1物理像素。

性能优化方面我做了几个关键点：一是用React.lazy实现路由级代码分割，首屏加载时间从3秒优化到1.2秒；二是对搜索功能做了防抖处理，避免频繁调用API；三是用Zustand的persist中间件来缓存用户数据，减少不必要的网络请求。

整个项目用了React 19配合Vite构建，开发体验很好。我还集成了Pexels API来获取高质量旅行图片，当API调用失败时会自动降级到备用图片源，保证用户体验的连续性。

这个项目让我对现代前端开发有了更深的理解，特别是在状态管理、性能优化和用户体验方面积累了很多实战经验。**

你的优势是什么
你对ai和全栈的理解
实现三栏布局
prototype和_proto_区别
手写new
手写promise
讲一下防抖节流
介绍一下react hook
这些东西你从哪学的
你人生中最痛苦的事情是什么
以后的发展打算
薪资


实习地点
实习时长
vue生命周期
介绍项目
防抖
流式输出
技能栈
对话功能实现
div 一行显示
同步和异步区别
echart怎么用的
ts和js的区别

**你对react有什么理解**
React 是一个用于构建用户界面的 JavaScript 库，核心思想是组件化开发和数据驱动视图。它的三大核心特点是：
组件化：将页面拆分为独立的组件，每个组件可复用、易维护，比如一个按钮组件可在多个页面重复使用。
虚拟DOM：通过内存中的虚拟DOM树对比差异，最小化真实DOM操作，大幅提升渲染效率。
单向数据流：数据从父组件流向子组件（通过props），状态集中管理（如配合Redux），避免数据混乱。
React还支持服务端渲染（Next.js）、跨平台开发（React Native），生态丰富，适合大型项目协作。

**请问react的子父通信 兄弟通信如何实现**
子组件通过 props 接收父组件传入的函数（回调函数），触发时将数据传递给父组件。（单向数据流）
子父组件通信（子 → 父）
原理：父组件传递一个回调函数给子组件，子组件通过调用该回调函数将数据传递回父组件。
兄弟通信：
状态提升：将共享状态交给共同的父组件管理，通过props传递给两个子组件。
Context API：创建共享上下文，避免逐层传递props。
第三方库：如Redux或MobX进行全局状态管理。

前后端是如何配合的
**讲讲js的特点**
JavaScript 是一门动态类型、弱类型、基于原型链的语言，特点包括：
动态类型：变量无需声明类型，运行时自动推断（如 let a = 1; a = "str"）。
事件驱动：以事件循环（Event Loop）为核心，擅长处理异步任务（如点击事件、AJAX请求）。
函数式编程：支持高阶函数、闭包、匿名函数，常用于回调和链式调用。
跨平台：通过Node.js可开发后端，结合Electron可开发桌面应用。
灵活性与缺陷：语法灵活但易写“脆弱代码”，需配合TypeScript或严格规范（ESLint）提升健壮性。
**es6有哪些新特性**
块级作用域：let/const 替代 var，避免变量污染。
箭头函数：简化函数写法，自动绑定 this。（它的 this 是从定义时的外层作用域 继承 而来的。这种特性被称为 词法作用域绑定（Lexical this Binding），即 this 的值在函数定义时就已经确定，而不是在调用时动态绑定。）
模板字符串：用反引号（`）拼接字符串和变量。
解构赋值：快速提取数组元素或对象属性。
模块化：import/export 替代CommonJS的 require。
类（Class）：提供更直观的面向对象语法（class Person {}）。
Promise：原生支持异步操作，替代回调地狱。
**讲讲js有哪些异步任务**
JavaScript的异步任务主要包括以下几种：
定时器：setTimeout和setInterval用于延迟或周期性执行代码。
事件处理：如用户交互事件（点击、输入）或浏览器事件（加载、网络请求）。
AJAX请求：通过XMLHttpRequest或Fetch API异步获取数据。
Promise和Async/Await：用于管理异步操作，避免回调地狱。
Web Workers：在后台线程执行脚本，不阻塞主线程。
微任务（Microtasks）：如Promise.then、MutationObserver，在宏任务结束后立即执行。
**说说索引有什么作用**
加速查询：通过B+树或哈希结构快速定位数据，避免全表扫描。
保证唯一性：如主键索引强制唯一性约束。
排序与分组优化：索引字段已排序，可加速 ORDER BY 和 GROUP BY 操作。
**索引是越多越好吗**
索引不是越多越好：
写入性能下降：每次插入/更新数据时，索引需要同步更新，增加开销。 。、
占用存储空间：每个索引都需要额外存储。
选择性低的索引无效：如性别字段（男/女）建索引效果差，因为选择性低。
建议：仅对高频查询字段、排序字段、唯一约束字段建索引，并定期分析索引使用情况（如通过 EXPLAIN 语句）。

熟悉React和Next.js吗
**懂得接口对接前后端联调吗**
熟悉！联调流程通常分三步：
接口文档确认：通过Swagger或Postman与后端约定好URL、参数格式（如JSON）、状态码。
Mock数据开发：前端可用工具模拟接口，提前开发页面逻辑。
真实联调与调试：用Axios或Fetch发送请求，处理异步数据，同时关注跨域（CORS）和错误边界。遇到问题时，我会先抓包分析请求是否成功，再检查后端日志定位错误。比如之前项目中因后端返回字段名拼写错误，导致数据无法渲染，通过联合排查快速解决。
**对API有所了解吗**
API（应用程序接口）是不同系统间通信的规范
会使用AI IDE吗
了解并尝试过一些AI IDE工具，如GitHub Copilot、VS(通义灵码)的AI插件等。它们能根据上下文智能补全代码、生成注释，甚至优化代码结构。例如，输入“创建一个React组件”，AI会自动生成基本框架，大幅提升开发效率。不过，目前更倾向于将其作为辅助工具，核心逻辑仍需自己理解和实现。
**主要做前端 咋没做后端**
前端是我的专长，但后端知识也在持续学习中。目前专注前端能更高效地解决用户交互和性能问题，但未来计划向全栈发展，已经学习了Node.js基础和一些后端框架，希望能在项目中实践前后端协作。
**自驱力和主观能动性如何**
自驱力方面，我会主动学习新技术（如最近研究WebAssembly），并尝试在项目中应用。例如，曾用TypeScript重构旧代码，减少60%的类型错误。主观能动性上，遇到问题会先独立思考，再寻求协作解决，比如曾优化项目加载速度，通过代码分割和懒加载使首屏加载时间减少30%。

自我介绍
项目展示
**对AI的理解**
AI是通过算法模拟人类智能行为的技术，核心包括机器学习、深度学习和自然语言处理等。比如，AI能通过大量数据训练模型，自动完成图像识别、语音助手、推荐系统等任务。它正在改变各行业——医疗领域辅助诊断、金融风控、自动驾驶等。但AI也面临挑战，比如数据隐私、算法偏见和伦理问题。我认为未来AI会更注重“人机协作”，成为提升效率的工具，而非完全替代人类。
**react的优势是什么**
组件化开发：将界面拆分为独立组件，提高复用性和维护性，比如一个按钮组件可复用到多个页面。
虚拟DOM：通过对比新旧DOM差异，最小化真实DOM操作，显著提升性能。
生态强大：配合Redux管理状态、React Router实现路由，且社区活跃，资源丰富。另外，单向数据流和JSX语法让开发更直观，尤其适合大型项目协作。
**了解ts吗**
了解！TypeScript 是 JavaScript 的超集，核心是静态类型检查。比如定义变量时指定类型，编译时就能发现错误，减少运行时BUG。它还支持接口、泛型等高级特性，提升代码可读性和团队协作效率。在React项目中，TS能强制组件props类型，避免传参错误。虽然初期学习成本略高，但长期看能降低维护成本。我之前在项目中用TS重构代码，确实减少了很多类型相关BUG。
**了解Electron吗**
了解！Electron 基于Chromium和Node.js，允许用HTML/CSS/JS开发跨平台桌面应用，比如VS Code、Slack。它的优势是开发效率高，前端开发者可快速上手，且能调用系统API（如文件操作）。但缺点是应用体积较大，性能不如原生应用。我曾用Electron做一个跨平台的本地日志分析工具，通过IPC通信实现主进程与渲染进程的数据交互，体验还不错。不过对性能要求高的场景，比如音视频处理，可能更适合原生开发。
**对未来的规划，发展方向**
短期目标是深入前端技术栈，比如掌握Web性能优化、微前端架构，同时提升TS和工程化能力（如CI/CD）。中期希望向全栈发展，了解后端服务设计（Node.js/Go），并探索AI在前端的应用，比如用模型优化用户体验。长期看，想成为技术负责人，主导复杂项目架构设计，同时保持对新技术（如Web3、AI工具）的敏感度。未来3年，我计划每年参与一个开源项目或技术分享，持续输出价值。

**虚拟 DOM 的目的是什么 为什么提出**
目的：
提升性能：
通过在内存中维护轻量级的虚拟 DOM 树，减少直接操作真实 DOM 的次数，避免频繁的重排（Reflow）和重绘（Repaint）。
使用 Diff 算法对比新旧虚拟 DOM 树，仅更新差异部分，实现最小化 DOM 操作。
批量更新 DOM，合并多次变更，减少性能损耗。
简化开发模型：
声明式编程（Declarative Programming）：开发者只需描述 UI 应该是什么样子，框架自动处理 DOM 更新逻辑。
避免手动操作 DOM，降低代码复杂性和出错概率。
跨平台能力：
虚拟 DOM 是 JavaScript 对象，可以抽象为跨平台渲染逻辑（如 React Native、Weex 等）。
提出原因：
真实 DOM 操作成本高，直接操作可能导致性能问题（如频繁的 Reflow/Repaint）。
传统命令式编程需要开发者手动管理 DOM，代码冗余且难以维护。
虚拟 DOM 提供了一种高效的中间层，平衡性能与开发效率。
**函数组件相对于类组件有什么好处**
类组件 函数组件
语法复杂度：
需要继承 React.Component，定义 render 方法，使用 this 绑定上下文。
语法简洁，直接定义函数，无需 this。
状态管理：
通过 this.state 和 this.setState 管理状态。
通过 useState Hook 管理状态。
生命周期方法：
需要定义生命周期方法（如 componentDidMount）。
通过 useEffect Hook 实现生命周期逻辑。
性能：
可能存在 this 绑定和类实例化开销。
更轻量，React 16.8 后通过 Hook 优化性能。
推荐使用场景：
React 早期版本的主流形式，适合复杂逻辑。
React 16.8 后的主流选择，简洁且支持 Hook 功能。
关键点：
函数组件通过 Hooks（如 useState、useEffect）实现了类组件的功能，同时语法更简洁，性能更优。
类组件逐渐被函数组件取代，但某些遗留项目或复杂场景仍可能使用类组件。

react 相对于 vue 有什么好处
**JWT 登录鉴权**
JWT（JSON Web Token） 是一种无状态的认证机制，常用于分布式系统中的身份验证。
核心流程：
登录阶段：
用户提交用户名和密码。
服务器验证成功后，生成一个 JWT（包含用户信息、过期时间等），并返回给客户端。
访问资源阶段：
客户端在后续请求中携带 JWT（通常放在 Authorization 头中）。
服务器验证 JWT 的签名和有效期，若合法则允许访问资源。
JWT 优势：
无状态：服务器无需存储会话信息，适合分布式架构。
跨域友好：Token 可跨域传递，不受同源策略限制。
安全性：通过签名（HMAC 或 RSA）防止 Token 被篡改。
自包含：Token 中包含用户信息，无需频繁查询数据库。
**移动端适配，插件**
H5 页面在移动端（尤其是 iOS）可能出现字体缩放异常或布局错乱的问题。
使用 postcss-px-to-viewport 插件将 px 单位自动转换为 vw（视口宽度单位），实现响应式适配。
**自定义hooks**
自定义 Hook 是以 use 开头的函数，可复用逻辑，帮助实现关注分离和代码模块化。
逻辑复用：将通用逻辑（如计数器、表单验证）封装为 Hook，供多个组件调用。
关注分离：将复杂逻辑抽离到独立 Hook 中，组件代码更简洁。
自定义 Hook 必须以 use 开头，内部可调用其他 Hook（如 useState、useEffect）。
通过返回值暴露状态和方法，组件无需关心实现细节。
**组件的封装**
目的：
提升开发效率：复用已封装的组件，避免重复代码。
维护性：将复杂逻辑拆分为小模块，降低维护成本。
一致性：统一 UI 风格和交互逻辑，符合设计规范。
组件分类：
功能组件：纯逻辑处理（如表单验证、请求封装）。
UI 组件：基础视图元素（如按钮、输入框）。
业务组件：结合业务逻辑的复杂组件（如用户登录面板）。
高阶组件（HOC）：通过组合逻辑增强组件功能。
封装原则：
单一职责：每个组件只负责一个功能。
接口明确：通过 props 和事件传递数据，解耦内外部逻辑。
可扩展性：预留扩展点，适应未来需求变化

为什么会选择react
**SSE 流式输出**
基于 HTTP 协议，单向通信（服务器 → 客户端）。
支持自动重连和流式传输（如 ChatGPT 逐字输出）。
数据格式为文本，通过 data: 字段传递。
适用场景：
实时更新（如新闻推送、AI 流式输出）。
无需客户端频繁发送请求的场景（如任务进度监控）。
**websocket有没有了解**
基于 TCP 的双向通信（客户端 ↔ 服务器）。
实时性更高，适合高频交互（如在线游戏、聊天室）。
需要手动管理连接和重连逻辑。
适用场景：
实时性要求高的双向通信（如实时协作编辑）。
传输二进制数据（如视频流、文件传输）。
**api 请求方式是怎么样的**
XMLHttpRequest（XHR）
传统方式，支持异步请求，但语法较复杂。
适用于旧项目或需要兼容低版本浏览器的场景。
Fetch API
现代标准，基于 Promise，语法简洁。
支持流式响应（如 response.body.getReader()）。
Beacon API
用于页面卸载时发送小数据（如埋点统计）。
保证数据发送成功，即使页面关闭。
SSE（Server-Sent Events）
用于服务器主动推送文本数据（如 AI 流式输出）。
示例：const eventSource = new EventSource('/stream')。
WebSocket
用于双向实时通信（如聊天室）。
示例：const socket = new WebSocket('wss://example.com')。

merge冲突，git 协作

**deepseek 如何实现流式输出**
客户端：通过 HTTP 请求发起流式请求（Accept: text/event-stream）。
服务器：
使用 HTTP/1.1 的 Transfer-Encoding: chunked 或 HTTP/2 的流式特性。
调用 AI 模型逐词生成内容，并封装为 SSE 事件（data: {chunk}）。
客户端：监听 onmessage 事件，逐块渲染内容（如打字机效果）。

调用过 deepseek API吗
**React 常见的hooks，一般用于做什么**
useState
用途：管理组件的局部状态。
useEffect
用途：执行副作用操作（如数据获取、订阅）。
useContext
用途：跨层级传递共享状态（避免 props 透传）。
useReducer
用途：管理复杂的状态逻辑（如表单验证、多步骤流程）。
useCallback / useMemo
用途：优化性能，避免重复渲染或计算。

**react 全局状态管理**
React 的全局状态管理主要用于跨组件共享和更新状态。常见的解决方案包括：
Context API 轻量级全局状态管理（如主题切换、用户登录状态） 
实现方式：通过 createContext 创建上下文，Provider 提供状态，useContext 消费状态。
Redux
使用场景：复杂应用的全局状态管理（如购物车、多模块交互）。
核心概念：
Action：描述状态变更的动作（如 { type: "increment" }）。
Reducer：纯函数，根据 Action 更新状态（不可变更新）。
Store：存储全局状态，通过 dispatch 触发 Action。
优势：状态集中管理，便于调试和测试。
Zustand / Jotai
使用场景：替代 Redux 的轻量方案，适合中小型项目。
特点：API 简洁，支持异步操作和中间件。
**介绍一下服务端组件和客户端组件使用场景**
服务端组件（Server Components）
特点：
在服务器上渲染，生成 HTML 后发送到客户端（SSR）。
不支持客户端交互（如 useState）。
使用场景：
静态内容展示（如文章列表、数据表格）。
需要 SEO 优化的页面（搜索引擎可直接抓取 HTML）。
减少客户端包体积（布局部分用服务端组件，交互部分用客户端组件）。
客户端组件（Client Components）
特点：
在浏览器中执行，支持交互（如 useState、事件监听）。
需要显式标记 use client（Next.js 13+）。
使用场景：
需要动态交互的 UI（如表单验证、动画）。
数据驱动的组件（通过 API 获取数据）。

css 了解的怎么样
**flex 布局哪些常用属性**
Flex 布局通过 display: flex 实现灵活的布局，常用属性包括：
容器属性
flex-direction：主轴方向（row / column）。
justify-content：主轴对齐方式（flex-start / center / space-between）。
align-items：交叉轴对齐方式（flex-start / stretch）。
flex-wrap：是否换行（nowrap / wrap）。
项目属性
flex-grow：扩展比例（如 flex-grow: 1 填满剩余空间）。
flex-shrink：收缩比例（默认 1，可压缩）。
align-self：覆盖容器的 align-items（如 center）。
**介绍一下promise**
Promise
用途：处理异步操作（如 AJAX 请求），避免回调地狱。
核心方法：
then()：处理成功状态。
catch()：处理失败状态。
finally()：无论成功或失败都会执行。
**发布者订阅模式**
发布-订阅模式（Pub/Sub Pattern）是一种行为型设计模式，用于解耦消息的发送者（发布者）和接收者（订阅者）。
它的核心是通过一个**中间媒介（事件中心）**来传递消息：
发布者：负责发布消息到特定主题（Topic/Event Name）。
订阅者：订阅感兴趣的主题，并在消息到达时执行回调函数。
事件中心：作为调度中心，负责消息的存储、匹配和派发。
特点：
完全解耦：发布者和订阅者互不依赖，无需知道对方存在。
一对多通信：一个发布者可以通知多个订阅者，一个订阅者也可以订阅多个主题。
异步友好：天然支持同步或异步处理，适合异步场景（如消息队列、跨组件通信）。
**usememo usecallback**
useMemo
用于缓存计算结果。它会在依赖项变化时重新执行计算函数，否则直接返回缓存值。
核心作用：避免重复执行高开销的计算，优化性能。
useCallback
用于缓存函数引用。它会在依赖项变化时返回新的函数，否则返回之前的缓存函数。
核心作用：避免频繁创建函数，优化子组件渲染性能（与 React.memo 配合使用）。
**es6新特性**
变量声明
let / const：块级作用域，避免变量提升。
解构赋值
数组/对象解构
模板字符串
使用反引号（`）插入变量
箭头函数
简化函数语法，但没有自己的this（它的 this 是从定义时的外层作用域 继承 而来的。这种特性被称为 词法作用域绑定（Lexical this Binding），即 this 的值在函数定义时就已经确定，而不是在调用时动态绑定。）
模块化
导入导出语法
Promise / async/await
异步操作的优雅写法

函数组件和类组件的区别
**useEffect,useState**
useState
用途：管理组件的内部状态，当状态变化时触发组件重新渲染。
useEffect
用途：处理副作用（如数据获取、订阅、手动操作 DOM），替代类组件中的 componentDidMount、componentDidUpdate、componentWillUnmount。
依赖数组：
若依赖项为空数组 []，副作用仅在组件挂载和卸载时执行。
若依赖项为 state 或 props，当它们变化时副作用重新执行。
**闭包**
闭包是指函数能够访问并记住其词法作用域，即使该函数在其作用域外执行。
内部函数引用外部函数的变量，即使外部函数已经执行完毕，变量也不会被释放。
优点
封装私有变量：避免全局污染。
持久化数据：变量长期存储在内存中（如计数器、缓存）。
缺点
内存泄漏风险：若闭包引用了大对象且未及时释放，可能导致内存占用过高。
html5
**如何实现水平居中，垂直居中**
Flexbox：
.parent {
  display: flex;
  justify-content: center; /* 水平居中 */
}
.parent {
  display: flex;
  align-items: center; /* 垂直居中 */
}
**浏览器页面渲染的过程**
解析 HTML 和 CSS
HTML 解析：生成 DOM 树。
CSS 解析：生成 CSSOM 树。
关键阻塞：浏览器会暂停 HTML 解析等待 CSS 加载（避免 FOUC）。
生成渲染树（Render Tree）
将 DOM 树和 CSSOM 树合并为 渲染树（忽略 display: none 的元素）。
布局（Layout）
计算每个节点的几何位置（宽度、高度、偏移量）。
触发条件：修改 DOM 结构、样式（如 width、height）。
绘制（Paint）
将渲染树的每个节点转换为像素（颜色、文本、边框等）。
合成（Composite）
将多个图层（Layer）合成为最终的像素输出到屏幕。

**虚拟DOM**
虚拟DOM（Virtual DOM）是真实DOM的轻量级JavaScript对象抽象，用于描述真实DOM的结构、属性和状态。它本质上是一个用JavaScript对象表示的树形结构（称为VNode树），与真实DOM一一对应。
虚拟DOM的核心思想是先在内存中操作JavaScript对象，再通过算法将变化同步到真实DOM，减少直接操作真实DOM的性能损耗。具体流程如下：
创建虚拟DOM
当组件状态（数据）发生变化时，框架（如Vue或React）会重新生成一个新的虚拟DOM树。
对比差异（Diff算法）
框架会将新旧两棵虚拟DOM树进行对比，找出需要更新的部分（如节点增删改）。
局部更新真实DOM
根据对比结果，只更新真实DOM中变化的部分（称为Patch过程），避免全量重绘/重排。
**请讲讲 React 和 Vue 的区别。**
React 和 Vue 是当前最主流的前端框架，两者在设计理念、核心机制和使用场景上存在显著差异。
React
单向数据流：通过 props 传递数据，强调不可变性（Immutable）和单向更新。
函数式编程：鼓励使用纯函数组件（Function Component）和 Hooks 实现逻辑复用。
虚拟 DOM：通过 Diff 算法高效更新真实 DOM，减少直接操作 DOM 的开销。
Vue
双向数据绑定：通过 v-model 实现表单数据的双向绑定，简化交互逻辑。
响应式系统：基于 Proxy（Vue3）或 Object.defineProperty（Vue2）实现数据劫持，自动追踪依赖并更新视图。
声明式语法：通过模板语法（如 {{ data }}）直接绑定数据，降低学习成本。
**防抖节流**
防抖（Debounce）
定义：在事件被频繁触发时，只有最后一次触发后经过指定时间未再次触发，才会执行函数。
核心思想：停止触发后才执行。
原理：
使用 setTimeout 延迟执行函数。
每次触发事件时，清除之前的定时器并重新计时。
关键点：定时器未执行前触发事件会重置计时。
应用场景：
搜索框输入（用户停止输入后发送请求）。
表单验证（停止输入后验证）。
窗口调整（调整完成后重新计算布局）。
节流（Throttle）
定义：在一定时间间隔内，无论事件触发多少次，函数只执行一次。
核心思想：固定时间间隔执行一次。
原理：
限制函数在固定时间间隔内只执行一次。
可通过 时间戳 或 定时器 实现。
应用场景：
滚动事件（页面滚动加载更多内容）。
鼠标移动事件（跟踪鼠标位置但不频繁响应）。
按钮点击（防止高频点击）。

**==和===**
==
特点：会进行隐式类型转换，比较值之前会尝试将操作数转换为相同类型。
工作机制：
如果类型相同，直接比较值。
如果类型不同，JavaScript会尝试转换类型后再比较。
===
特点：不进行类型转换，要求值和类型必须完全相同。
工作机制：
如果类型不同，直接返回false。
如果类型相同，再比较值是否相等。
**事件循环**
事件循环是 JavaScript 实现异步编程的核心机制。由于 JavaScript 是单线程语言（主线程只能依次执行任务），事件循环通过任务队列和调度策略协调异步操作（如定时器、网络请求）与同步代码的执行，避免主线程被阻塞。
先处理微任务，再处理宏任务
事件循环的核心组件
3.1 调用栈（Call Stack）
存储函数调用的上下文（执行上下文）。
同步代码按顺序压入栈，执行完后弹出。
3.2 任务队列
分为两种类型：
宏任务队列（Macrotask Queue）：
setTimeout、setInterval、I/O 操作（如 fetch）、UI 渲染、事件回调等。
每次事件循环处理一个宏任务。
微任务队列（Microtask Queue）：
Promise.then/.catch、MutationObserver、queueMicrotask、async/await 等。
优先级高于宏任务，会在当前宏任务结束后立即执行所有微任务。
事件循环的执行流程
执行同步代码：
将同步代码压入调用栈，逐行执行。
处理微任务：
所有微任务（如 Promise 回调）会被加入微任务队列。
同步代码执行完毕后，立即清空微任务队列（按顺序执行所有微任务）。
处理宏任务：
从宏任务队列中取出一个任务，执行并压入调用栈。
执行完宏任务后，进入下一轮事件循环。